package com.arcdb.jdbc

import com.google.gson.Gson
import com.google.gson.JsonObject
import java.sql.*

class ArcStatement(private val _connection: ArcConnection) : Statement {
    var closed = false
    var currentResultSet: ResultSet? = null
    var _updateCount = -1

    override fun executeQuery(sql: String): ResultSet {
        if (!execute(sql)) {
             throw SQLException("Query did not return a ResultSet")
        }
        return currentResultSet!!
    }

    override fun executeUpdate(sql: String): Int {
        if (execute(sql)) {
             throw SQLException("Query returned a ResultSet")
        }
        return _updateCount
    }

    override fun execute(sql: String): Boolean {
        if (closed) throw SQLException("Statement is closed")

        _connection.writer.println(sql)
        val response = _connection.reader.readLine()
            ?: throw SQLException("Connection closed unexpectedly")

        val gson = Gson()
        val json = try {
            gson.fromJson(response, JsonObject::class.java)
        } catch (e: Exception) {
            throw SQLException("Invalid JSON response: $response")
        }

        if (json.has("message") && json.has("status") && json.get("status").asString == "error") {
            throw SQLException(json.get("message").asString)
        }

        if (json.has("affected_rows")) {
             // UPDATE/INSERT/DELETE or empty result
             _updateCount = json.get("affected_rows").asInt
             currentResultSet = null
             
             // If columns are present but empty, it's still a ResultSet
             if (json.has("columns") && json.has("rows")) {
                 currentResultSet = ArcResultSet(this, json)
                 _updateCount = -1
                 return true
             }
             return false
        } else if (json.has("columns") && json.has("rows")) {
             // SELECT
             currentResultSet = ArcResultSet(this, json)
             _updateCount = -1
             return true
        }

        throw SQLException("Unknown response format: $response")
    }

    override fun getResultSet(): ResultSet? = currentResultSet
    override fun getUpdateCount(): Int = _updateCount
    override fun close() { closed = true }

    // Boilerplate
    override fun getMaxFieldSize() = 0
    override fun setMaxFieldSize(max: Int) {}
    override fun getMaxRows() = 0
    override fun setMaxRows(max: Int) {}
    override fun setEscapeProcessing(enable: Boolean) {}
    override fun getQueryTimeout() = 0
    override fun setQueryTimeout(seconds: Int) {}
    override fun cancel() {}
    override fun getWarnings() = null
    override fun clearWarnings() {}
    override fun setCursorName(name: String?) {}
    override fun getMoreResults() = false
    override fun setFetchDirection(direction: Int) {}
    override fun getFetchDirection() = ResultSet.FETCH_FORWARD
    override fun setFetchSize(rows: Int) {}
    override fun getFetchSize() = 0
    override fun getResultSetConcurrency() = ResultSet.CONCUR_READ_ONLY
    override fun getResultSetType() = ResultSet.TYPE_FORWARD_ONLY
    override fun addBatch(sql: String?) {}
    override fun clearBatch() {}
    override fun executeBatch() = IntArray(0)
    override fun getConnection() = _connection
    override fun getMoreResults(current: Int) = false
    override fun getGeneratedKeys(): ResultSet = throw SQLFeatureNotSupportedException()
    override fun execute(sql: String?, autoGeneratedKeys: Int) = execute(sql!!)
    override fun execute(sql: String?, columnIndexes: IntArray?) = execute(sql!!)
    override fun execute(sql: String?, columnNames: Array<out String>?) = execute(sql!!)
    override fun getResultSetHoldability() = ResultSet.HOLD_CURSORS_OVER_COMMIT
    override fun isClosed() = closed
    override fun setPoolable(poolable: Boolean) {}
    override fun isPoolable() = false
    override fun closeOnCompletion() {}
    override fun isCloseOnCompletion() = false
    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int = executeUpdate(sql!!)
    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int = executeUpdate(sql!!)
    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int = executeUpdate(sql!!)

    override fun <T : Any?> unwrap(iface: Class<T>?): T = throw SQLException("Not implemented")
    override fun isWrapperFor(iface: Class<*>?): Boolean = false
}
